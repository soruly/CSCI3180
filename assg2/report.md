1.	Achieving polymorphism by duck typing and by inheritance
a.	Duck typing determines the object (instance) by checking its behavior. This is achieved by checking whether the object can respond to a method. This design is more flexible. As in Task 2, when holdParty(person) is called, it just check if the person has the method attendClub, then invoke that persons’ own implementation of that method. It is OK to assume that only club members have a method named attendClub. So, in this case, we do not care what kind of person he is, and no need to declare another class ClubMember.
The drawback (aside from run-time error) is that some method names are ambiguous. For example, both animals and program can have a method called run. But their meanings are completely different. Duck typing would not tell if it is a program or an animal, as both of them can “run”. This would result unexpected behavior that may not even throw an error at run-time.
b.	Inheritance is more concrete design. If different type of object shares some methods and attributes, we can use a parent class for these subclasses. In Task 2, in order to know if we can call the seeDoctor method, we check if the object is a Doctor or Patient. (instead of checking whether it has such method) Since these two types of people inherit the parent class HospitalMember, we can sure that either Doctor or Patient instance can call the method seeDoctor. Since Java is statically typed, it can detect type errors when it compiles. This would reduce run-time errors.


2.	A scenario that Ruby implementation is better than Java implementation
a.	In task 2, the module (used for FoodBuying) is a very good feature provided by Ruby. When we call module in Doctor and Patient, FoodBuying becomes another superclass of them. So, aside from methods in HospitalMember, they also have methods in FoodBuying. We cannot extent multiple classes in Java, but we can include multiple modules in Ruby. Moreover, the Visitor class, which is not a subclass of HospitalMember, can include the same module. This may be similar to interface in Java, but it is not. Interface does not have the implementation the method until it is written in the class that implements it. The module in Ruby contains the implementation of the method. Once the module is included, there is no need to define the method again.
